# 組み込み開発

組み込みデバイス向けのプログラミングは砂漠での生活に少し似ています。あらゆる資源が乏しく、常に配分を工夫し、炎天下を避ける必要があります。

このドキュメントは、Carp で資源配分をどう最適化するかをまとめたガイドです。まずは何を最優先に節約したいのかを明らかにしましょう。実行ファイルのサイズでしょうか？ タイミングがシビアなコードでしょうか？ それとも動的確保を避けたいのでしょうか？ それらの問いに答えが出れば、このガイドが目的地までの道筋を示してくれます。

Carp は C にコンパイルされるため、多くの考慮事項やテクニック、思考法は C と共通です。すでに必要なコンパイラフラグが分かっているならそのまま使えますし、Carp はたいてい素直に応えてくれます。それでも、Carp が提供するツールを把握しておくと、作業効率がぐっと上がるはずです。

## まずはイメージ

可能性を感じてもらうために、ちょっとした写真をどうぞ。
<img src="carp_on_arduboy.jpg">


## 基礎知識

コンパイラを思いどおりに操るには、設定項目をしっかり把握しておく必要があります。この章では、プロジェクトをビルドする際に使える手段を概観します。

### コンパイラ設定

コンパイラを制御する動的関数がいくつか用意されています。主なものは次のとおりです。

```clojure
; 利用する C コンパイラを指定
(Project.config "compiler" "mycompiler")

; コンパイラに追加で渡すフラグを指定
(add-cflag "-myflag")

; リンク時に渡すライブラリフラグを指定
(add-lib "-mylibflag")

; 指定したライブラリの cflags / libs を pkg-config で取得
(add-pkg "mypkg")
```

### クロスコンパイル

組み込み開発ではクロスコンパイラを使うのが一般的です。使用方法はマニュアルのクロスコンパイルの章を参照してください。

### 条件付きコンパイル

コンパイルホストの情報を取得するためのマクロも用意されています。まずはホスト環境を調べる関数を見てみましょう。

```clojure
; ホスト OS を返す
(host-os)

; ホストのアーキテクチャ（32/64 など）を返す
(host-bit-width)
```

多くの場合は、ホストではなくターゲットプラットフォームの詳細が必要になるでしょう。

```clojure
; ターゲットのアーキテクチャを返す
(target-arch)

; ターゲット OS を返す
(target-os)

; ターゲット ABI を返す
(target-abi)
```

条件付きコード用のマクロが `Macros.carp` にいくつか用意されています。ターゲットに OS が存在しない場合は、`freestanding` ターゲット向けに独自マクロを定義することになるかもしれません。


### 切り札を使う

独自のリンカスクリプトを使うなど、かなり特殊な手順が必要になる場合もあります。その際は、Carp に C コードだけを生成させ、自分で後処理を行うのが近道かもしれません。`--generate-only` を指定すれば、その状態で止められます。

場合によっては、プレリュードが通常読み込むファイルを除外し、自前のコアロードファイルを生成する必要も出てきます。`--no-core` を指定すれば実現できます。あとは[既定のプレリュード](https://github.com/carp-lang/Carp/blob/master/core/Core.carp)をテンプレートにして自分用に調整してください。

## 何を最適化するか

### バイナリサイズ

Carp は標準ではバイナリサイズを最適化しませんが、[リンク時最適化 (LTO)](https://wiki.debian.org/LTO) や、コンパイラのサイズ最適化オプションを併用するとかなり削減できます（GCC/Clang であれば `(add-cflag "-Os")` が簡単です）。

### 実行速度

多くの場合、速度よりも優先したい要素がありますが、どうしてもミリ秒単位まで詰めたいなら最適化フラグを最大にするのが手頃です（一般的には `-O3` と Carp の `--optimize`）。とはいえ、速度向上にはコードの書き方が大きく影響します。確保やコピー、キャッシュミスを避けるほうが、最適化フラグより効果的なことも多いでしょう。

### メモリ確保

確保を避けるテクニックもいくつかあります。リテラル文字列は標準でバイナリに埋め込まれ、コピーしない限り確保は発生しません。同様に、リテラルの静的配列（`$[]`）を使えば確保を回避できますが、サイズと構造はコンパイル時に確定していなければなりません。

開発・デバッグ中にメモリ確保をログしたい場合は、Carp コンパイラに `--log-memory` を渡し、プログラムの冒頭で `(Debug.log-memory-balance! true)` を呼びます。これで、どこで確保が発生しているかを追跡でき、意図せぬ確保の洗い出しに役立ちます。
