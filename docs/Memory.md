# メモリ管理を詳しく見る

Carp は *線形型システム* を用いて、プログラム中のさまざまな値に紐づくメモリを管理します。この仕組みは次の目標を念頭に設計・実装されています。

* **予測可能性**: 振る舞いが分かりやすく、推論しやすいこと。
* **効率性**: 実行速度に大きな悪影響を与えないこと。
* **安全性**: 「解放済みメモリの使用」や「二重解放」といったメモリ管理上の典型的なバグを防ぐこと。

本書では Carp の線形型システムが備える基本概念と、実装の概要を紹介します。

## 線形型とメモリ管理

Carp の線形型システムは、型シグネチャの一部として値に紐づくメモリの *所有権* を追跡します。いわゆる *線形型* とは、従来の型に *ライフタイム* と呼ばれる追加情報が付いたものです。ライフタイムによって、型システムは値がどのメモリ領域に紐づいているかを把握できます。

メモリ管理システムが扱うのは線形型だけです。すべての型が線形であるわけではありません。Carp の組み込み型のうち、以下はデフォルトで線形です。

- `String`
- `Pattern`
- `Array`
- `Box`
- 関数型

その他の組み込み型は線形ではなく、メモリ管理システムの対象外です。

ユーザ定義型が線形と見なされるかどうかは次の条件で決まります。

- **`blit` インタフェースを実装している場合**: その型は明示的に「非線形」として扱われ、メモリ管理システムの対象外となります。割り当て・解放にまつわるリスクがないと判断されます。
- **`delete` インタフェースを実装している場合**: その型は「線形」であると認識され、メモリ管理システムが管理します。型に紐づく値のメモリを安全に解放できると判断されたタイミングで `delete` が呼ばれます。

`deftype` で型を定義すると、Carp は自動的に `delete` インタフェースを実装します。つまり `deftype` で作成した型は基本的にメモリ管理システムが面倒を見ます。多くの場合、この挙動は望ましいものです。必要であれば `delete` を再実装してカスタム解放処理を記述できます。ただし、より細かい制御が必要なら、型と解放処理を C 側で実装し Carp に登録するほうが適しているかもしれません。

[C インタロップ](./CInterop.md) で登録した型についても同様の条件が適用されます。C で定義した外部型を登録しただけでは Carp 側の管理対象にならず、`delete` 実装を提供して初めて管理されます。詳しくは上記ドキュメントを参照してください。

以下では、線形型の代表として組み込みの `String` を例に挙げながら、メモリ管理システムの主要な操作を順に見ていきます。

## 束縛・所有権・レキシカルスコープ

プログラムがある程度の規模になると、名前と値を結び付ける *束縛*（バインディング）が複数登場します。一般的には、ある束縛の値を別の束縛へ代入できます。次の `let` 式を例に見てみましょう。

```clojure
(let [x 1
      y x
      z x]
  x)
```

非線形な値 `1` を `x` に束縛し、それを `y` や `z` に代入しています。

Carp では線形値は異なる扱いになります。線形値を束縛（ローカル変数など）に代入すると、値に結び付いた *メモリの所在* もその名前に紐づきます。そのため、値の代入や受け渡しに関するルールが変わってきます。先ほどと同じことを線形型 `String` で行うとどうなるでしょうか。

```clojure
(let [string @"linear types!"
      other-string string ;; ここで使用！
      yet-another-string string] ;; ここでも！
  string) ;; さらにここでも！
```

このコードを Carp コンパイラに渡すと `You’re using a given-away value string` というエラーが返ってきます。

これがメモリ管理システムが守る「黄金律」です。**線形値は各レキシカルスコープで一度しか利用できません**。`@"linear types!"` を `string` に束縛した時点で一度使用した扱いになり、その後 `string` を複数の場所で使用しようとする（`other-string` や `yet-another-string` に代入する、戻り値として返すなど）とエラーになります。ただし `string` を `other-string` へ代入し、戻り値として `other-string` を返すといったケースは許容されます。理由は後ほど説明します。

一般的な言い方をすると、これは *所有権* の概念です。線形値を束縛したブロック（今回であれば `string`）がそのメモリの所有者になります。各束縛はレキシカルスコープを持ち、そのスコープ内でのみ適切に利用できます。

線形値は、同じレキシカルスコープ内で *別のスコープへ渡すたびに* 利用済みと見なされます。たとえば戻り値として返す場合や、別の関数に渡す場合がこれに該当します。

```clojure
(let [string @"linear types!"]
  string) ;; ここで使用！
```

```clojure
(let [string @"linear types!"]
  (do (reverse string) ;; ここで使用！
      ()))
```

いずれのケースでも、`string` に結び付いたメモリが別の束縛へ移動する可能性があります。これが後述する「ムーブ（所有権の移動）」です。

### 安全な解放

「一度きりの利用」制約が、`use-after-free` や `double free` といった古典的バグを防止します。線形値が各スコープで一度しか使用されないよう管理することで、どのタイミングでメモリを解放できるかを正確に判断できます。所有者のスコープで再利用されないと判断された時点で、自動的に `delete` 実装が呼び出されます。

## ムーブ、借用、コピー

線形型システムの振る舞いは大きく「ムーブ」「借用」「コピー」の 3 つに整理できます。以下ではこれらを順に見ていきます。

### ムーブ ― 所有権の移動

線形値に紐づくメモリを所有できるのは常に 1 つの束縛だけです。そのため、同じ線形値を複数の変数へ同時に代入することはできません。代わりに、既存の束縛から別の束縛へ代入すると *所有権の移動*（ムーブ）が発生し、元の束縛は無効化されます。

```clojure
(let [string @"linear types!"
      other-string string
      yet-another-string string] ;; ここでエラー！
  ())
```

上の例では `string` を `other-string` に代入した時点で `string` は使えなくなります。メモリの所有者は `other-string` に移ります。この操作を「ムーブ」と呼びます。

同じスコープ内でも、束縛を順に移動させれば問題ありません。重要なのは、**同一束縛からのムーブは 1 度だけ** というルールです。

```clojure
(let [string @"linear types!"
      other-string string
      yet-another-string other-string]
  ())
```

### スコープをまたぐムーブ

ムーブの対象は同じスコープ内に限りません。戻り値として返す場合もムーブが発生します。

```clojure
(let [string @"linear moves!"]
  string)
```

この例でも所有権が呼び出し元へ移動します。同様に、関数へ引数として渡す場合もムーブです。

```clojure
(let [string @"linear moves!"
      reversed (reverse string)]
  reversed)
```

ここでは `string` の値を `reverse` の引数へ渡した時点で所有権が移動しています。

### 借用 ― 一時的な参照

複数回利用したいからと言って、同じ束縛から 2 度ムーブするとエラーになるのは先ほど見たとおりです。

```clojure
(let [string @"linear moves!"
      other-string string
      yet-another-string string] ;; エラー！
  ())
```

しかし、同じ値を複数回処理したいケースは多々あります。そこで役に立つのが *借用*（参照）です。線形値への参照は線形ではないため、通常の値と同じように渡せます。所有権を移動させるのではなく、一時的にアクセスを許可するイメージです。参照は `&`（または `ref`）で生成します。

```clojure
(let [string @"hello, linear world!"
      reversed (reverse &string)]
  (concatenate string reversed))
```

`reverse` に渡しているのは `string` の参照なので、`string` 自体はまだムーブされていません。これにより、後段の `concatenate` で所有権を移動させることができます。

### コピー ― 値を複製する

参照を受け取った関数内部では、どう使えばよいでしょうか。通常、参照に対して許されるのは *コピー* です。参照をコピーすると、参照先の線形値を複製した新たな線形値が得られます。複製元とは独立した所有者を持ち、メモリ管理システムが適切なタイミングで解放します。

参照の値をコピーするには `@` を使います。`reverse` 関数を次のように実装できるでしょう。

```clojure
(defn reverse [string-ref]
  (reverse-internal @string-ref))
```

`string-ref` が指す文字列をコピーし、そのコピーを反転させて返しています。元の値には触れていません。

ここで、文字列リテラル記法 `@"..."` の意味も明らかになります。リテラルは参照として扱われ、バインドされる際にコピーされるのです。

## 実際的な指針

関数の引数や戻り値がメモリ管理上どう扱われるのか知りたい場合は、関数の型を見るのが手っ取り早い方法です（現状は `(env)` などで確認できます）。戻り値や引数が `String` や `Vector3` のような「参照でない構造体型」であれば、所有権が移動する意味合いになります。一方、`(Ref String)` のような参照型であれば、一時的に貸し出されるだけで解放責任は呼び出し側にありません。既存の C コードと連携する場合は、Carp 側のデータ構造を参照やポインタ（`(Pointer.address <variable>)`）として渡し、メモリ管理を Carp 側に留めるのが妥当なことが多いでしょう。

## 配列の扱い

Carp では配列データを処理することが非常に重要です。以下はその典型例です。

```clojure
(defn weird-sum []
  (let [stuff [3 5 8 9 10]]
    (reduce add 0 &(endo-map square (filter even? stuff)))))
```

`endo-map` や `filter` のような配列変換関数は C のミュータブル操作を利用しており、元のデータ構造を再利用します。追加の確保や解放は必要ありません。ライフタイム解析器（Rust の「借用チェッカ」に相当）が同じデータ構造を複数箇所で同時に使っていないかを検証します。

`endo-map` は入力と同じ型の配列を返す必要があります。そうでない場合は `copy-map` を使ってください。`copy-` という接頭辞は、新しいメモリを確保することを示す目印です。
