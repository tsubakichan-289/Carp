# マクロ

マクロは Lisp 系言語の中でも賛否が大きく分かれる機能です。設計上の選択肢が多く、各アプローチに擁護者と反対者が存在します。

このドキュメントでは、Carp のマクロシステム全体とその使い方を解説します。急いでいる方や、お気に入りのマクロ機能が Carp にあるかどうかだけ知りたい方は、まず [「概要」](#概要) をご覧ください。マクロを実際に使いこなしたい、あるいは実装を理解したい場合は、[「マクロの使い方」](#マクロの使い方) と [「内部構造」](#内部構造) が役に立つでしょう。

## 概要

Carp のマクロシステムは比較的シンプルで、以下の特徴を持ちます。

- 衛生的（hygienic）ではありませんが、`gensym` を利用できます。
- 準クォートは現時点で未実装です（構想がないわけではなく、単にまだ導入されていません）。そのためマクロの基本ツールは `car`、`cdr`、`cons`、`list` になります。
- `defmacro` ベースの分かりやすい構文でマクロを定義でき、コンパイル時／動的関数を併用できます（詳しくは[「マクロの使い方」](#マクロの使い方) を参照）。
- 動的環境はマクロを展開してコードを生成する場であると同時に、コンパイルに関する追加情報を伝える場としても活用されます。例として、`Project.config` という動的関数を使うと C コンパイラやプロジェクト名、出力ディレクトリなどを設定できます。実際の例として、動的環境で複数コンパイラに対応したビルドシステムを実装している[コードスニペット](https://github.com/carpentry-org/snippets/blob/master/build_system.carp)があります。

## マクロの使い方

マクロは `defmacro` プリミティブで定義します。

```clojure
(defmacro apply [f args] (cons f args))

(apply + (1 2)) ; => (+ 1 2)
(apply Array.replicate (5 "hello")) ; => (Array.replicate 5 "hello")
```

上の例では、関数とリストで表現された引数を受け取り、それらを `cons` で結合して関数適用の形に書き換える `apply` マクロを定義しています。

マクロである `apply` に渡すリストはクォート不要です。それが気になるなら、代わりに動的関数として定義することもできます。動的関数は引数を評価する一方、マクロは本体で展開される点が異なります。動的関数は次のように定義します。

```clojure
(defndynamic apply [f args] (cons f args))

(apply '+ '(1 2)) ; => (+ 1 2)
(apply 'Array.replicate '(5 "hello")) ; => (Array.replicate 5 "hello")
```

マクロ版と比べると、`defndynamic` を使っていることと、呼び出し側で引数にクォートを付けている以外はほとんど同じです。

マクロでは可変長引数を扱うために「残り引数」を受け取れます。最後の引数名の前に `:rest` を付けると、その位置以降の引数をリストとして受け取ります。

```clojure
(defmacro apply-or-sym [head :rest tail]
  (if (= (length tail) 0)
    head
    (cons head tail)))

(apply-or-sym *global*) ; => *global*
(apply-or-sym + 1 2) ; => (+ 1 2)
```

`apply-or-sym` は少々ふざけた例ですが、仕組みを理解するには分かりやすいでしょう。形式引数 `head` の後に任意個の引数を渡すと、それらは `tail` というリストに束縛されます。引数が 1 つだけなら `head` をそのまま返し、複数あるなら通常の関数呼び出しと同じように扱います。実際にはもっと有用な用途があり、残り引数はたくさんのケースで活躍します。

マクロの実例をさらに見たい場合は、[標準ライブラリのマクロ定義](../core/Macros.carp)や、比較的大規模なマクロである [`fmt`](../core/Format.carp) を参照すると良いでしょう。

REPL でマクロを調べる際に便利な関数として `expand`、`eval`、`macro-log` があります。`expand` はマクロを展開し、`eval` は展開後のコードを評価します。`macro-log` はマクロ内部の動作を追跡する際に役立つ“printf デバッグ”的なツールです。

## 内部構造

Carp コンパイラはいくつかの段階に分かれています。以下の図はコンパイラの処理フローを示したものです。

![The compiler passes](./compiler-passes.svg)

動的評価器は Carp コンパイラで最も重要な要素のひとつで、マクロ展開・借用チェック・型推論などを指揮します。関数定義や変数、`let` 束縛など、これらの処理を必要とするフォームに出会うたびに対応します。

したがって、評価器の仕組みを理解すれば Carp 全体の動きを把握しやすくなります。動的評価器を学ぶ際の出発点としては、[`src/Eval.hs`](../src/Eval.hs) にある `eval` 関数が最適です。

### データ構造

`eval` の型シグネチャは次のとおりです。

```haskell
eval :: Context -> XObj -> IO (Context, Either EvalError XObj)
```

この関数を理解するには、最低限 `Context`、`XObj`、`EvalError` を把握する必要があります。`IO` と `Either` は Haskell 標準ライブラリの型なので詳細説明は割愛します（[Stackage](https://stackage.org) などのドキュメントを参照してください）。

以下で解説するデータ構造はすべて [`src/Obj.hs`](../src/Obj.hs) に定義されています。

#### `XObj`

`XObj` は “`Obj` with eXtras” の略です。`Obj` は Carp の AST ノードを表す型で、コンパイラ全体で使用されます。多くの場合、`Obj` は `XObj` に包まれており、`XObj` は追加情報を付与します。具体的には、`info` フィールド（`Maybe Info`）がソースコード上の位置などを保持し、`ty` フィールド（`Maybe Ty`）が型情報を保持します。本ドキュメントでは話を簡単にするため、これらを省略し、`XObj` は単なる AST ノードだと考えます。そうすると、`eval` は「コンテキストと AST ノードを受け取り、新しいコンテキストとエラーもしくは新しい AST ノードを返す関数」と捉えられます。

#### `Context`

`Context` は Carp コンパイラ全体の状態を保持するデータ構造です。型・値環境から、スタックトレース用に辿った評価フレームの履歴まで、多くの情報を含みます。コンパイラの状態を知りたい場合はコンテキストを調べればわかります。

#### `EvalError`

動的評価器がエラーに遭遇すると `EvalError` が生成されます。エラーメッセージに加え、トレースバックやソース位置などのメタ情報を含みます。

### 評価

Carp の動的評価器は、式の評価に加えて定義などのメタレベル情報も扱います。つまり、定義は特別な構文ではなく、評価すべき動的プリミティブとして扱われます。多くの定義関連フォームは特殊フォームではなく、Haskell で実装された `Primitive` として提供されています。

ここで、評価器が扱う構文の種類を整理しておきます。

- **特殊フォーム**: 抽象構文木上に専用のノードを持ち、評価ループ内で直接扱われる構文です。`fn` や `the` が該当します。高階関数のように値として受け渡すことはできません。
- **プリミティブ**: 引数を評価しない通常の Carp フォームで、Haskell で実装された組み込みマクロに相当します。`defmacro`、`defn`、`quote` などが該当します。
- **コマンド**: こちらも通常の Carp フォームですが、引数を評価し、組み込み関数として振る舞います。`Project.config`、`car`、`cons` などです。

プリミティブは主に [`src/Primitives.hs`](../src/Primitives.hs)、コマンドは [`src/Commands.hs`](../src/Commands.hs)、特殊フォームは `eval` 関数内にあります。これらは [`src/StartingEnv.hs`](../src/StartingEnv.hs) で環境に登録され、名前が与えられます。

#### 特殊フォーム／プリミティブ／コマンドを追加するには

Carp の評価器に新しいプリミティブやコマンドを追加するには多くの仕組みがありますが、開始を助ける便利な関数も用意されています。既存のランタイム関数と同じ名前を使用する場合は、可能な限りその挙動を再現するようにしてください。

特殊フォームを追加するのはやや大掛かりで、`eval` の理解や保守を難しくしないよう慎重に判断しています。新しい特殊フォームを検討する際は、まず[チャット](https://gitter.im/carp-lang/carp) で相談することをおすすめします。

#### 現在存在する特殊フォーム一覧

特殊フォームは“魔法のような存在”なので列挙しておきます。現在のところ以下が定義されています。

- `if` — 分岐
- `defn` — 関数定義
- `def` — グローバル変数定義
- `let` — ローカル変数束縛
- `the` — 型注釈
- `fn` — 関数リテラル
